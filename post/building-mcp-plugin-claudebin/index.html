<!doctype html><html lang=en><head><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,minimum-scale=1"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel=stylesheet><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.1/styles/atom-one-light.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.1/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><meta charset=utf-8><meta name=robots content="index,follow"><link rel=canonical href=https://blog.vtemian.com/post/building-mcp-plugin-claudebin/><link rel=icon type=image/svg+xml href=https://blog.vtemian.com/favicon.svg><link rel=apple-touch-icon href=https://blog.vtemian.com/favicon.svg><meta name=keywords content="mcp,model context protocol,claude code plugin,mcp server,json-rpc,claudebin,opencode,agentic programming"><meta name=description content="A technical deep dive into building claudebin as an MCP server for Claude Code. Covers the JSON-RPC wire protocol, session extraction, device authorization, and an honest comparison with OpenCode's direct plugin model."><meta property="og:url" content="https://blog.vtemian.com/post/building-mcp-plugin-claudebin/"><meta property="og:site_name" content="vtemian - blog"><meta property="og:title" content="Building an MCP Plugin for Claude Code"><meta property="og:description" content="A technical deep dive into building claudebin as an MCP server for Claude Code. Covers the JSON-RPC wire protocol, session extraction, device authorization, and an honest comparison with OpenCode's direct plugin model."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:published_time" content="2026-02-27T10:00:00+02:00"><meta property="article:modified_time" content="2026-02-27T10:00:00+02:00"><meta property="article:tag" content="Mcp"><meta property="article:tag" content="Agentic-Programming"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Deep-Dive"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Building an MCP Plugin for Claude Code"><meta name=twitter:description content="A technical deep dive into building claudebin as an MCP server for Claude Code. Covers the JSON-RPC wire protocol, session extraction, device authorization, and an honest comparison with OpenCode's direct plugin model."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.vtemian.com\/post\/building-mcp-plugin-claudebin\/"},"headline":"Building an MCP Plugin for Claude Code","description":"A technical deep dive into building claudebin as an MCP server for Claude Code. Covers the JSON-RPC wire protocol, session extraction, device authorization, and an honest comparison with OpenCode\u0027s direct plugin model.","inLanguage":"en-US","author":{"@type":"Person","name":"Vlad Temian","url":"https:\/\/blog.vtemian.com\/","sameAs":["https://github.com/vtemian","https://linkedin.com/in/vtemian","https://x.com/vtemian"]},"publisher":{"@type":"Person","name":"Vlad Temian"},"datePublished":"2026-02-27T10:00:00\u002b02:00","dateModified":"2026-02-27T10:00:00\u002b02:00","url":"https:\/\/blog.vtemian.com\/post\/building-mcp-plugin-claudebin\/","wordCount":1216,"timeRequired":"PT6M","keywords":["mcp","agentic-programming","typescript","deep-dive"]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/blog.vtemian.com\/"},{"@type":"ListItem","position":2,"name":"Post","item":"https:\/\/blog.vtemian.com\/post/"},{"@type":"ListItem","position":3,"name":"Building an MCP Plugin for Claude Code","item":"https:\/\/blog.vtemian.com\/post\/building-mcp-plugin-claudebin\/"}]}</script><title>Building an MCP Plugin for Claude Code</title>
<link rel=stylesheet href=https://blog.vtemian.com/stylesheets/main.min.a6be239ab41f81525e7ac2406cecae00f6b48f1426e31b2642f2cfcf0df0b951.css media=screen><meta name=google-site-verification content="2qk_e0y84NNSVpaorKgeNURYF9Ni3UyJvPq9GZdGEgs"></head><body><div class=container><main class=article><article><header><a href=https://blog.vtemian.com/>&larr; Go back</a><h1>Building an MCP Plugin for Claude Code</h1><p class=article-date>27 Feb 2026 · 6 min read</p></header><p><p>Claude Code sessions live as <code>.jsonl</code> files under <code>~/.claude/projects/</code>. They&rsquo;re ephemeral. You debug a race condition, the agent rewrites three files, and then it&rsquo;s gone. <a href=https://claudebin.com>Claudebin</a> turns any session into a shareable URL. Run <code>/claudebin:share</code>, get back a permanent link.</p><p>This post is about what&rsquo;s underneath. Building an MCP server, shipping it as a Claude Code plugin, and where the architecture shines vs where it falls apart.</p><h2 id=mcp-json-rpc-20-over-stdio>MCP: JSON-RPC 2.0 Over stdio</h2><p>The <a href=https://modelcontextprotocol.io/>Model Context Protocol</a> sits on top of <a href=https://www.jsonrpc.org/specification>JSON-RPC 2.0</a>. Claude Code spawns your server as a child process, pipes stdin/stdout, and exchanges newline-delimited JSON. No HTTP, no WebSockets, no port allocation. One child process per MCP server, lifecycle tied to the parent.</p><p>When Claude Code starts your server, it sends an <code>initialize</code> request:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>→</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>1</span>,<span style=color:#f92672>&#34;method&#34;</span>:<span style=color:#e6db74>&#34;initialize&#34;</span>,<span style=color:#f92672>&#34;params&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;protocolVersion&#34;</span>:<span style=color:#e6db74>&#34;2024-11-05&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;capabilities&#34;</span>:{<span style=color:#f92672>&#34;roots&#34;</span>:{<span style=color:#f92672>&#34;listChanged&#34;</span>:<span style=color:#66d9ef>true</span>}},
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;clientInfo&#34;</span>:{<span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;claude-code&#34;</span>,<span style=color:#f92672>&#34;version&#34;</span>:<span style=color:#e6db74>&#34;1.0.0&#34;</span>}}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>←</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>1</span>,<span style=color:#f92672>&#34;result&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;protocolVersion&#34;</span>:<span style=color:#e6db74>&#34;2024-11-05&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;capabilities&#34;</span>:{<span style=color:#f92672>&#34;tools&#34;</span>:{}},
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;serverInfo&#34;</span>:{<span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;claudebin&#34;</span>,<span style=color:#f92672>&#34;version&#34;</span>:<span style=color:#e6db74>&#34;1.0.0&#34;</span>}}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>→</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;method&#34;</span>:<span style=color:#e6db74>&#34;notifications/initialized&#34;</span>}
</span></span></code></pre></div><p>Capability negotiation. The client declares what it supports, the server responds with its own. Claudebin only declares <code>tools</code>. The third message is a notification (no <code>id</code>, no response expected), signaling the handshake is complete.</p><p>Then Claude discovers tools via <code>tools/list</code> and invokes them via <code>tools/call</code>. The tool response uses MCP&rsquo;s content block format:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>←</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>3</span>,<span style=color:#f92672>&#34;result&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;content&#34;</span>:[{<span style=color:#f92672>&#34;type&#34;</span>:<span style=color:#e6db74>&#34;text&#34;</span>,<span style=color:#f92672>&#34;text&#34;</span>:<span style=color:#e6db74>&#34;https://claudebin.com/threads/abc123&#34;</span>}]}}
</span></span></code></pre></div><p>MCP separates <em>protocol errors</em> (malformed JSON-RPC) from <em>tool errors</em> (your code ran but failed). Tool errors return a successful response with <code>isError: true</code>. The distinction matters because Claude can reason about tool errors and retry. Protocol errors are opaque.</p><p>One gotcha with the long-lived process model: <code>console.log</code> goes to stdout and corrupts the JSON-RPC stream. This bites every new MCP developer. Use <code>console.error</code> for debugging.</p><h2 id=session-extraction>Session Extraction</h2><p>The genuinely hard part of claudebin is figuring out where Claude stores sessions and extracting the right one.</p><p>Sessions are <code>.jsonl</code> files under <code>~/.claude/projects/</code>. The directory name is a normalized project path. <code>/Users/vlad/projects/my-app</code> becomes <code>Users-vlad-projects-my-app</code>. Every non-alphanumeric character maps to a dash:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>normalizeProjectPath</span>(<span style=color:#a6e22e>projectPath</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>projectPath</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>/^\//</span>, <span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>/[^a-zA-Z0-9]/g</span>, <span style=color:#e6db74>&#34;-&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is undocumented. I found it by reading Claude Code&rsquo;s source and verifying against the filesystem. Getting it wrong means a silent &ldquo;session not found&rdquo; error.</p><p>The directory contains multiple files:</p><pre tabindex=0><code>~/.claude/projects/Users-vlad-projects-my-app/
├── default.jsonl          # Main conversation
├── agent-a1b2c3d4.jsonl   # Subagent session (Task tool)
├── agent-e5f6g7h8.jsonl   # Another subagent
</code></pre><p>Claudebin filters out <code>agent-*</code> files and picks the most recent by <code>mtime</code>. Each JSONL line is a self-contained message object (user message, assistant response, tool call, tool result). The file is read as a UTF-8 string and sent as-is to the backend for rendering.</p><p>The memory trade-off: Node.js strings are UTF-16 internally, so a 50MB session becomes ~100MB of heap. Add JSON serialization for the HTTP body and you hit ~200MB peak. A streaming upload would fix this, but for typical sessions (100KB-5MB) it wasn&rsquo;t worth the complexity. The 50MB limit is a client-side safety valve.</p><h2 id=device-authorization>Device Authorization</h2><p>MCP servers run in a terminal. No browser window, no OAuth redirect URI. Claudebin uses a pattern similar to <a href=https://datatracker.ietf.org/doc/html/rfc8628>RFC 8628 (Device Authorization Grant)</a>:</p><pre tabindex=0><code>Plugin                         Backend                      Browser
  │                              │                            │
  ├── POST /api/auth/start ────→ │                            │
  ← { code: &#34;abc&#34;, url: &#34;...&#34; } │                            │
  ├── exec(&#34;open&#34;, url) ────────────────────────────────────→ │
  │                              │                    User logs in
  │                              │ ←── POST /api/auth/verify ─┤
  ├── GET /api/auth/poll?code= → │                            │
  │   (every 2s, up to 5min)     │                            │
  ← { accessToken, refreshToken }│                            │
</code></pre><p>The one-time code correlates the CLI and browser session. Tokens are cached in <code>~/.claudebin/config.json</code> with <code>0o600</code> permissions (same pattern as <code>~/.ssh/</code>). Before every share, claudebin checks the cached token. If it&rsquo;s within 5 minutes of expiry, it refreshes proactively rather than failing mid-upload.</p><p>Both auth and session publishing use async polling. Rather than duplicate the retry logic, claudebin has a generic <code>poll&lt;T>()</code> with configurable interval, timeout, and a type guard callback. Auth polls for 5 minutes (user might be slow). Session processing polls for 2 minutes. No backoff, fixed 2-second interval. For a single-user CLI tool generating 30 req/min during a poll, this is fine.</p><p>Why not WebSockets? Connection lifecycle management, stateful load balancing, maintaining a persistent socket alongside the stdio event loop. The polling implementation is 20 lines. A robust WebSocket client is 200+. For a 5-15 second wait, 2 seconds of overhead is acceptable.</p><h2 id=the-indirection-problem>The Indirection Problem</h2><p>Let&rsquo;s be honest about what happens when a user types <code>/claudebin:share</code>:</p><pre tabindex=0><code>&#34;/claudebin:share&#34;
  → Claude reads commands/share.md (markdown with YAML frontmatter)
  → Markdown body becomes instructions injected into Claude&#39;s context
  → Claude interprets instructions and decides to call the MCP tool
  → Claude constructs a tools/call JSON-RPC message
  → Serialized over stdio to the child process
  → MCP SDK deserializes, Zod validates, dispatches to handler
  → Handler runs, result serialized back
  → Claude reads response, formats for user
</code></pre><p>Four layers of indirection between &ldquo;user wants to share&rdquo; and &ldquo;code runs.&rdquo;</p><p>Compare this to <a href=https://opencode.ai/>OpenCode</a> (the platform <a href=https://github.com/vtemian/micode>micode</a> extends):</p><pre tabindex=0><code>&#34;/init&#34;
  → Command config maps to agent &#34;project-initializer&#34; with a template
  → Agent calls tools via typed function dispatch
</code></pre><p>In OpenCode, a tool is a TypeScript function registered in-process. No IPC, no serialization, no child process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ast_grep_search</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tool</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>description</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Search code patterns using AST-aware matching&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>args</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pattern</span>: <span style=color:#66d9ef>tool.schema.string</span>().<span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#34;AST pattern&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lang</span>: <span style=color:#66d9ef>tool.schema.enum</span>(<span style=color:#a6e22e>LANGUAGES</span>).<span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#34;Target language&#34;</span>),
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>execute</span>: <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>context</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>runSg</span>(<span style=color:#a6e22e>args</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>formatMatches</span>(<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>matches</span>);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Commands map deterministically to agents. <code>/init</code> always routes to <code>project-initializer</code>. Always. The template is filled via string substitution, not LLM inference.</p><p>In Claude Code, the slash command is natural language that Claude <em>interprets</em>. The dispatch is non-deterministic. Claude usually gets it right, but the path goes through model reasoning. If instructions are ambiguous, Claude might ask questions instead of calling the tool.</p><h3 id=the-trade-offs>The Trade-offs</h3><table><thead><tr><th></th><th>MCP (Claude Code)</th><th>Direct Plugin (OpenCode)</th></tr></thead><tbody><tr><td>Tool dispatch</td><td>LLM inference</td><td>Hash map lookup</td></tr><tr><td>State sharing</td><td>Filesystem/external only</td><td>In-process context</td></tr><tr><td>Language support</td><td>Any (JSON-RPC over stdio)</td><td>JS/TS only (Bun runtime)</td></tr><tr><td>Process isolation</td><td>Yes (child process)</td><td>No (shared process)</td></tr><tr><td>Portability</td><td>Claude Code, Cursor, Zed&mldr;</td><td>OpenCode only</td></tr><tr><td>Debug experience</td><td>Multi-layer, stderr only</td><td>Standard debugging</td></tr><tr><td>Latency overhead</td><td>~1-2s (model thinking)</td><td>Negligible</td></tr></tbody></table><p>MCP earns its keep on language agnosticism and ecosystem portability. Claudebin is TypeScript. I&rsquo;ve also built MCP servers in Python with Playwright for browser automation. MCP doesn&rsquo;t care what language you use. OpenCode plugins must be JS/TS compiled for Bun.</p><p>Process isolation matters too. An MCP server that crashes doesn&rsquo;t take down Claude Code. A segfaulting native module in an OpenCode plugin kills the entire process.</p><p>But the developer experience is worse. When your tool doesn&rsquo;t receive the right arguments, you have to figure out which of four layers failed. Did Claude misinterpret the markdown? Did it construct the wrong arguments? Did Zod reject valid input? You end up writing to a debug file and tailing it in another terminal because <code>console.log</code> corrupts stdout.</p><h3 id=the-honest-assessment>The Honest Assessment</h3><p>MCP is the right choice when you value portability over performance. It&rsquo;s the wrong choice when you need tight integration, state sharing, and deterministic dispatch.</p><p>I&rsquo;ve shipped multiple MCP servers and an OpenCode plugin with 22 agents. If a tool needs to work across editors, MCP is the only game in town. If it only needs one platform, skip the protocol and go direct.</p><p>MCP is to agent tooling what REST was to web services in 2008. Verbose, imperfect, too much ceremony for simple cases. But it&rsquo;s becoming the standard. Building against a standard, even an imperfect one, compounds over time.</p><p>The code is at <a href=https://github.com/wunderlabs-dev/claudebin>github.com/wunderlabs-dev/claudebin</a>.</p><p>Stay curious ☕</p></p></article></main><script>hljs.initHighlightingOnLoad()</script><footer class=footer>&copy; 2026 <a href=https://github.com/vtemian>Vlad Temian</a>,
powered by <a href=https://gohugo.io/ target=_blank>Hugo</a>,
with help from <a href=https://github.com/balajmarius>&copy;balajmarius</a>.</footer></div></body></html>