<!doctype html><html lang=en><head><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,minimum-scale=1"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel=stylesheet><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.1/styles/atom-one-light.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.1/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><meta charset=utf-8><meta name=robots content="index,follow"><link rel=canonical href=https://blog.vtemian.com/post/building-mcp-plugin-claudebin/><link rel=icon type=image/svg+xml href=https://blog.vtemian.com/favicon.svg><link rel=apple-touch-icon href=https://blog.vtemian.com/favicon.svg><meta name=keywords content="mcp,model context protocol,claude code,claude code plugin,mcp server,json-rpc,claudebin,opencode,agent tooling,agentic programming"><meta name=description content="How I built a session-sharing plugin using the Model Context Protocol. From stdio transport and JSON-RPC wire protocol to device authorization, async polling, and an honest comparison with OpenCode's direct plugin model."><meta property="og:url" content="https://blog.vtemian.com/post/building-mcp-plugin-claudebin/"><meta property="og:site_name" content="vtemian - blog"><meta property="og:title" content="Building an MCP Plugin for Claude Code: A Deep Dive with Claudebin"><meta property="og:description" content="How I built a session-sharing plugin using the Model Context Protocol. From stdio transport and JSON-RPC wire protocol to device authorization, async polling, and an honest comparison with OpenCode's direct plugin model."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:published_time" content="2026-02-27T10:00:00+02:00"><meta property="article:modified_time" content="2026-02-27T10:00:00+02:00"><meta property="article:tag" content="Mcp"><meta property="article:tag" content="Agentic-Programming"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Deep-Dive"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Building an MCP Plugin for Claude Code: A Deep Dive with Claudebin"><meta name=twitter:description content="How I built a session-sharing plugin using the Model Context Protocol. From stdio transport and JSON-RPC wire protocol to device authorization, async polling, and an honest comparison with OpenCode's direct plugin model."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.vtemian.com\/post\/building-mcp-plugin-claudebin\/"},"headline":"Building an MCP Plugin for Claude Code: A Deep Dive with Claudebin","description":"How I built a session-sharing plugin using the Model Context Protocol. From stdio transport and JSON-RPC wire protocol to device authorization, async polling, and an honest comparison with OpenCode\u0027s direct plugin model.","inLanguage":"en-US","author":{"@type":"Person","name":"Vlad Temian","url":"https:\/\/blog.vtemian.com\/","sameAs":["https://github.com/vtemian","https://linkedin.com/in/vtemian","https://x.com/vtemian"]},"publisher":{"@type":"Person","name":"Vlad Temian"},"datePublished":"2026-02-27T10:00:00\u002b02:00","dateModified":"2026-02-27T10:00:00\u002b02:00","url":"https:\/\/blog.vtemian.com\/post\/building-mcp-plugin-claudebin\/","wordCount":4468,"timeRequired":"PT22M","keywords":["mcp","agentic-programming","typescript","deep-dive"]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/blog.vtemian.com\/"},{"@type":"ListItem","position":2,"name":"Post","item":"https:\/\/blog.vtemian.com\/post/"},{"@type":"ListItem","position":3,"name":"Building an MCP Plugin for Claude Code: A Deep Dive with Claudebin","item":"https:\/\/blog.vtemian.com\/post\/building-mcp-plugin-claudebin\/"}]}</script><title>Building an MCP Plugin for Claude Code: A Deep Dive with Claudebin</title>
<link rel=stylesheet href=https://blog.vtemian.com/stylesheets/main.min.a6be239ab41f81525e7ac2406cecae00f6b48f1426e31b2642f2cfcf0df0b951.css media=screen><meta name=google-site-verification content="2qk_e0y84NNSVpaorKgeNURYF9Ni3UyJvPq9GZdGEgs"></head><body><div class=container><main class=article><article><header><a href=https://blog.vtemian.com/>&larr; Go back</a><h1>Building an MCP Plugin for Claude Code: A Deep Dive with Claudebin</h1><p class=article-date>27 Feb 2026 · 22 min read</p></header><p><p>Claude Code sessions are ephemeral. You have a 45-minute conversation where you debug a gnarly race condition, the agent rewrites three files, and then it&rsquo;s gone. Buried in a <code>.jsonl</code> file somewhere under <code>~/.claude/projects/</code>. No way to share it, reference it, or learn from it later.</p><p>That bothered me enough to build <a href=https://claudebin.com>claudebin</a>, a plugin that turns any Claude Code session into a permanent, shareable URL. Run <code>/claudebin:share</code>, get back <code>claudebin.com/threads/abc123</code>. Done.</p><p>But this post isn&rsquo;t about claudebin the product. It&rsquo;s about what I learned building an MCP server that ships as a Claude Code plugin. If you&rsquo;re thinking about extending Claude Code with custom tools, this is the practical guide I wish I had.</p><h2 id=mcp-under-the-hood-json-rpc-20-over-stdio>MCP Under the Hood: JSON-RPC 2.0 Over stdio</h2><p>The Model Context Protocol is a thin layer on top of <a href=https://www.jsonrpc.org/specification>JSON-RPC 2.0</a>. Claude Code spawns your server as a child process, connects its stdin/stdout to a pipe, and exchanges newline-delimited JSON messages. No HTTP, no WebSockets, no port allocation. The process model is deliberately simple: one child process per MCP server, lifecycle tied to the parent.</p><p>Let&rsquo;s look at what actually goes over the wire. When Claude Code starts your server, the first thing it sends is an <code>initialize</code> request:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>→</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>1</span>,<span style=color:#f92672>&#34;method&#34;</span>:<span style=color:#e6db74>&#34;initialize&#34;</span>,<span style=color:#f92672>&#34;params&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;protocolVersion&#34;</span>:<span style=color:#e6db74>&#34;2024-11-05&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;capabilities&#34;</span>:{<span style=color:#f92672>&#34;roots&#34;</span>:{<span style=color:#f92672>&#34;listChanged&#34;</span>:<span style=color:#66d9ef>true</span>}},
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;clientInfo&#34;</span>:{<span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;claude-code&#34;</span>,<span style=color:#f92672>&#34;version&#34;</span>:<span style=color:#e6db74>&#34;1.0.0&#34;</span>}
</span></span><span style=display:flex><span>  }}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>←</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>1</span>,<span style=color:#f92672>&#34;result&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;protocolVersion&#34;</span>:<span style=color:#e6db74>&#34;2024-11-05&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;capabilities&#34;</span>:{<span style=color:#f92672>&#34;tools&#34;</span>:{}},
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;serverInfo&#34;</span>:{<span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;claudebin&#34;</span>,<span style=color:#f92672>&#34;version&#34;</span>:<span style=color:#e6db74>&#34;1.0.0&#34;</span>}
</span></span><span style=display:flex><span>  }}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>→</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;method&#34;</span>:<span style=color:#e6db74>&#34;notifications/initialized&#34;</span>}
</span></span></code></pre></div><p>This is a capability negotiation handshake. The client declares what it supports (root listing, sampling, etc.), the server responds with its capabilities. Claudebin only declares <code>tools</code>. It doesn&rsquo;t provide resources or prompts. The third message is a notification (no <code>id</code> field, no response expected), signaling the handshake is complete.</p><p>After initialization, Claude discovers available tools via <code>tools/list</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>→</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>2</span>,<span style=color:#f92672>&#34;method&#34;</span>:<span style=color:#e6db74>&#34;tools/list&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>←</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>2</span>,<span style=color:#f92672>&#34;result&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;tools&#34;</span>:[{
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;share&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;description&#34;</span>:<span style=color:#e6db74>&#34;Share the current Claude Code session to Claudebin&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;inputSchema&#34;</span>:{
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;type&#34;</span>:<span style=color:#e6db74>&#34;object&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;properties&#34;</span>:{
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;project_path&#34;</span>:{<span style=color:#f92672>&#34;type&#34;</span>:<span style=color:#e6db74>&#34;string&#34;</span>,<span style=color:#f92672>&#34;description&#34;</span>:<span style=color:#e6db74>&#34;Absolute path to the project directory&#34;</span>},
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;title&#34;</span>:{<span style=color:#f92672>&#34;type&#34;</span>:<span style=color:#e6db74>&#34;string&#34;</span>,<span style=color:#f92672>&#34;description&#34;</span>:<span style=color:#e6db74>&#34;Optional title for the session&#34;</span>},
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;is_public&#34;</span>:{<span style=color:#f92672>&#34;type&#34;</span>:<span style=color:#e6db74>&#34;boolean&#34;</span>,<span style=color:#f92672>&#34;default&#34;</span>:<span style=color:#66d9ef>true</span>,<span style=color:#f92672>&#34;description&#34;</span>:<span style=color:#e6db74>&#34;Whether the session appears in public listings&#34;</span>}
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;required&#34;</span>:[<span style=color:#e6db74>&#34;project_path&#34;</span>]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>  }}
</span></span></code></pre></div><p>That <code>inputSchema</code> is a standard JSON Schema object. Claude uses it to understand what arguments your tool expects. The property names, types, and descriptions all feed into the model&rsquo;s tool-use reasoning. When a user runs <code>/claudebin:share</code>, Claude reads this schema, infers that <code>project_path</code> should be the current working directory, and constructs the <code>tools/call</code> request:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>→</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>3</span>,<span style=color:#f92672>&#34;method&#34;</span>:<span style=color:#e6db74>&#34;tools/call&#34;</span>,<span style=color:#f92672>&#34;params&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;share&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;arguments&#34;</span>:{<span style=color:#f92672>&#34;project_path&#34;</span>:<span style=color:#e6db74>&#34;/Users/vlad/projects/dd&#34;</span>,<span style=color:#f92672>&#34;is_public&#34;</span>:<span style=color:#66d9ef>true</span>}
</span></span><span style=display:flex><span>  }}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>←</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>3</span>,<span style=color:#f92672>&#34;result&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;content&#34;</span>:[{<span style=color:#f92672>&#34;type&#34;</span>:<span style=color:#e6db74>&#34;text&#34;</span>,<span style=color:#f92672>&#34;text&#34;</span>:<span style=color:#e6db74>&#34;https://claudebin.com/threads/abc123&#34;</span>}]
</span></span><span style=display:flex><span>  }}
</span></span></code></pre></div><p>The response uses MCP&rsquo;s content block format, an array of typed content items. Your tool can return <code>text</code>, <code>image</code> (base64-encoded), or <code>resource</code> (URI references). Claudebin returns a plain text URL. Error responses use the <code>isError</code> flag:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>←</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>3</span>,<span style=color:#f92672>&#34;result&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;content&#34;</span>:[{<span style=color:#f92672>&#34;type&#34;</span>:<span style=color:#e6db74>&#34;text&#34;</span>,<span style=color:#f92672>&#34;text&#34;</span>:<span style=color:#e6db74>&#34;Session file not found&#34;</span>}],
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;isError&#34;</span>:<span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  }}
</span></span></code></pre></div><p>This is an important distinction. MCP separates <em>protocol errors</em> (malformed JSON-RPC, unknown method) from <em>tool errors</em> (your tool ran but failed). Protocol errors use JSON-RPC&rsquo;s <code>error</code> field. Tool errors use a successful response with <code>isError: true</code>. The reason: Claude can reason about tool errors and retry or adjust. Protocol errors are opaque failures.</p><p>All of this wire protocol detail is handled by the SDK. You never construct these messages manually. But understanding what&rsquo;s beneath the abstraction matters, especially when debugging why Claude isn&rsquo;t passing the arguments you expect, or why your tool&rsquo;s response isn&rsquo;t rendering correctly.</p><h2 id=the-process-model-and-server-lifecycle>The Process Model and Server Lifecycle</h2><p>When Claude Code encounters an MCP server in its configuration, it spawns it as a child process using the command specified in <code>.mcp.json</code>. The stdio transport means the process stays alive for the duration of the Claude Code session. It&rsquo;s not a request/response fork-per-call model. The server initializes once, registers its tools, and then sits in an event loop waiting for JSON-RPC messages on stdin.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>McpServer</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;@modelcontextprotocol/sdk/server/mcp.js&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>StdioServerTransport</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;@modelcontextprotocol/sdk/server/stdio.js&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>registerTools</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;./tools/index.js&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>server</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>McpServer</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;claudebin&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>version</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;1.0.0&#34;</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>registerTools</span>(<span style=color:#a6e22e>server</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>main() {</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>transport</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>StdioServerTransport</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>connect</span>(<span style=color:#a6e22e>transport</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span>().<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>);
</span></span></code></pre></div><p>The <code>StdioServerTransport</code> wraps <code>process.stdin</code> and <code>process.stdout</code> into a message-oriented stream. Under the hood, it buffers incoming bytes, splits on newlines, parses each line as JSON-RPC, and dispatches to the appropriate handler. Outgoing messages are serialized, newline-terminated, and flushed to stdout.</p><p>One implication of the long-lived process model: anything you <code>console.log</code> goes to stdout and corrupts the JSON-RPC stream. This is the first thing that bites new MCP developers. Use <code>console.error</code> (which goes to stderr) for debug logging, or better yet, use the SDK&rsquo;s built-in logging that routes through the MCP protocol itself.</p><h2 id=zod-as-a-schema-bridge>Zod as a Schema Bridge</h2><p>Claudebin registers its tool with Zod schemas for input validation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>z</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;zod&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>tool</span>(
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;share&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;Share the current Claude Code session to Claudebin&#34;</span>,
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>project_path</span>: <span style=color:#66d9ef>z.string</span>().<span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#34;Absolute path to the project directory&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>title</span>: <span style=color:#66d9ef>z.string</span>().<span style=color:#a6e22e>optional</span>().<span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#34;Optional title for the session&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>is_public</span>: <span style=color:#66d9ef>z.boolean</span>().<span style=color:#66d9ef>default</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#34;Whether the session appears in public listings&#34;</span>),
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> ({ <span style=color:#a6e22e>project_path</span>, <span style=color:#a6e22e>title</span>, <span style=color:#a6e22e>is_public</span> }) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handler logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Zod schemas serve triple duty here. First, they generate the JSON Schema returned in <code>tools/list</code>. The MCP SDK calls <code>zodToJsonSchema()</code> internally to produce the <code>inputSchema</code> that Claude reads. Second, they validate incoming arguments at runtime before your handler executes. If Claude sends a malformed <code>project_path</code>, Zod throws before your code runs. Third, they provide TypeScript type inference. The handler callback gets fully typed parameters without manual type assertions.</p><p>The <code>.describe()</code> calls are more important than they look. Those strings become the <code>description</code> field in the JSON Schema, and they&rsquo;re what Claude reads to decide how to populate the arguments. A vague description like &ldquo;path&rdquo; means Claude might pass a relative path or a file path. &ldquo;Absolute path to the project directory&rdquo; tells Claude exactly what&rsquo;s needed. The quality of your Zod descriptions directly affects tool-use accuracy.</p><h2 id=parsing-claudes-session-storage>Parsing Claude&rsquo;s Session Storage</h2><p>The core challenge of claudebin isn&rsquo;t the MCP protocol. It&rsquo;s reverse-engineering how Claude Code persists sessions locally and extracting the right data.</p><p>Claude Code stores conversations as <code>.jsonl</code> files under <code>~/.claude/projects/</code>. Each line is a self-contained JSON object representing a conversation turn. The directory name is a deterministic transformation of the project&rsquo;s absolute path:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>normalizeProjectPath</span>(<span style=color:#a6e22e>projectPath</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>projectPath</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>/^\//</span>, <span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>/[^a-zA-Z0-9]/g</span>, <span style=color:#e6db74>&#34;-&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>/Users/vlad/projects/my-app</code> becomes <code>Users-vlad-projects-my-app</code>. Every non-alphanumeric character, including dots, underscores, and tildes, maps to a dash. This is an undocumented implementation detail I found by reading Claude Code&rsquo;s source and verifying against the filesystem. Getting it wrong means your plugin silently produces a &ldquo;session not found&rdquo; error with no useful diagnostic.</p><p>The directory structure under a project looks like this:</p><pre tabindex=0><code>~/.claude/projects/Users-vlad-projects-my-app/
├── default.jsonl          # Main conversation
├── agent-a1b2c3d4.jsonl   # Subagent session (Task tool)
├── agent-e5f6g7h8.jsonl   # Another subagent
└── ...
</code></pre><p>Claude spawns subagent sessions when it uses the Task tool internally. Each gets its own <code>agent-*</code> prefixed JSONL file. These are implementation artifacts, not user-facing conversations. Claudebin filters them out and picks the most recent non-agent session by <code>mtime</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>sessionDir</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>join</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>homedir</span>(), <span style=color:#e6db74>&#34;.claude&#34;</span>, <span style=color:#e6db74>&#34;projects&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>normalizeProjectPath</span>(<span style=color:#a6e22e>projectPath</span>)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>files</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readdir</span>(<span style=color:#a6e22e>sessionDir</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>jsonlFiles</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>files</span>
</span></span><span style=display:flex><span>  .<span style=color:#a6e22e>filter</span>(<span style=color:#a6e22e>f</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>endsWith</span>(<span style=color:#e6db74>&#34;.jsonl&#34;</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#34;agent-&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>withStats</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>Promise</span>.<span style=color:#a6e22e>all</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>jsonlFiles</span>.<span style=color:#a6e22e>map</span>(<span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>f</span>) <span style=color:#f92672>=&gt;</span> ({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>f</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mtime</span><span style=color:#f92672>:</span> (<span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>stat</span>(<span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>join</span>(<span style=color:#a6e22e>sessionDir</span>, <span style=color:#a6e22e>f</span>))).<span style=color:#a6e22e>mtimeMs</span>,
</span></span><span style=display:flex><span>  }))
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>withStats</span>.<span style=color:#a6e22e>sort</span>((<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>mtime</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>mtime</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>content</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFile</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>join</span>(<span style=color:#a6e22e>sessionDir</span>, <span style=color:#a6e22e>withStats</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>name</span>), <span style=color:#e6db74>&#34;utf-8&#34;</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>The JSONL content itself is a sequence of message objects: user messages, assistant responses, tool calls, tool results. Each line is independently valid JSON, which means you can process sessions line-by-line without loading the entire file into a parsed object graph. Claudebin doesn&rsquo;t take advantage of this today. It reads the full file as a UTF-8 string and sends it as-is to the backend for parsing. The backend handles the JSONL-to-rendered-HTML transformation.</p><h3 id=the-memory-trade-off>The Memory Trade-off</h3><p>Reading the entire file into a single <code>string</code> allocation means the V8 heap needs to hold the full session content. Node.js strings are UTF-16 internally, so a 50MB UTF-8 file becomes ~100MB of heap. Add the JSON serialization for the HTTP request body and you&rsquo;re looking at ~200MB peak allocation for a max-size session. The <code>--max-old-space-size</code> default of 4GB means this isn&rsquo;t a practical concern, but it&rsquo;s the kind of detail that matters if you&rsquo;re building for constrained environments.</p><p>A streaming alternative would use <code>fs.createReadStream()</code> piped through a multipart upload. The backend would need to accept chunked transfers and reassemble. For claudebin&rsquo;s typical session size (100KB-5MB), the complexity wasn&rsquo;t justified. The 50MB client-side limit exists as a safety valve.</p><h2 id=device-authorization-auth-without-a-redirect-uri>Device Authorization: Auth Without a Redirect URI</h2><p>MCP servers run inside a terminal. There&rsquo;s no browser window to redirect to, no localhost server to catch an OAuth callback. The standard Authorization Code flow with PKCE doesn&rsquo;t work because there&rsquo;s no redirect URI.</p><p>Claudebin uses a pattern similar to <a href=https://datatracker.ietf.org/doc/html/rfc8628>RFC 8628 (Device Authorization Grant)</a>: the server generates a one-time code, opens the user&rsquo;s browser to a verification page, and polls for completion.</p><p>The flow in detail:</p><pre tabindex=0><code>Plugin                         Backend                      Browser
  │                              │                            │
  ├── POST /api/auth/start ────→ │                            │
  │                              ├── Generate code + URL      │
  ← { code: &#34;abc&#34;, url: &#34;...&#34; } │                            │
  │                              │                            │
  ├── exec(&#34;open&#34;, url) ────────────────────────────────────→ │
  │                              │                            ├── User logs in
  │                              │ ←── POST /api/auth/verify ─┤
  │                              ├── Mark code as verified    │
  │                              │                            │
  ├── GET /api/auth/poll?code= → │                            │
  │   (every 2s, up to 5min)     ├── Code verified?           │
  ← { accessToken, refreshToken, │   Yes → return tokens      │
  │   expiresAt }                │                            │
</code></pre><p>The one-time <code>code</code> is the correlation key between the CLI process and the browser session. It&rsquo;s generated server-side, never sent over the browser URL as a secret. The URL contains the code for the user to verify, but the actual token exchange happens server-to-server on the poll endpoint.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>authenticateViaBrowser</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>AuthTokens</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>code</span>, <span style=color:#a6e22e>authUrl</span> } <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>startAuth</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>openUrl</span>(<span style=color:#a6e22e>authUrl</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>poll</span>&lt;<span style=color:#f92672>AuthTokens</span>&gt;({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fn</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>pollAuth</span>(<span style=color:#a6e22e>code</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>isReady</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>result</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>interval</span>: <span style=color:#66d9ef>AUTH_POLL_INTERVAL</span>,    <span style=color:#75715e>// 2 seconds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>timeout</span>: <span style=color:#66d9ef>AUTH_TIMEOUT</span>,           <span style=color:#75715e>// 5 minutes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>timeoutError</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Authentication timed out&#34;</span>,
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Cross-platform URL opening is one of those details that looks trivial but has edge cases:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>openUrl</span>(<span style=color:#a6e22e>url</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>void</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>escaped</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>/&#34;/g</span>, <span style=color:#e6db74>&#39;\\&#34;&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cmd</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>platform</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;darwin&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>?</span> <span style=color:#e6db74>`open &#34;</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>escaped</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;`</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>platform</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;win32&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>?</span> <span style=color:#e6db74>`start &#34;&#34; &#34;</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>escaped</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;`</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>:</span> <span style=color:#e6db74>`xdg-open &#34;</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>escaped</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;`</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exec</span>(<span style=color:#a6e22e>cmd</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The Windows <code>start</code> command needs an empty string as the window title before the URL. Without it, URLs containing spaces or special characters are misinterpreted as the title argument. The shell escaping handles URLs with query parameters, but there are known issues with URLs containing single quotes on Linux where <code>xdg-open</code> passes through <code>sh -c</code>.</p><h3 id=token-lifecycle-and-secure-storage>Token Lifecycle and Secure Storage</h3><p>Nobody wants to open a browser every time they share a session. Claudebin implements a three-tier token resolution strategy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getValidToken</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>string</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>loadConfig</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Tier 1: Valid cached token
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>accessToken</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>isExpiringSoon</span>(<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>expiresAt</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>accessToken</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Tier 2: Refresh expired token
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>refreshToken</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>refreshed</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>refreshToken</span>(<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>refreshToken</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>refreshed</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>saveConfig</span>(<span style=color:#a6e22e>refreshed</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>refreshed</span>.<span style=color:#a6e22e>accessToken</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Tier 3: Full browser auth flow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>authenticateViaBrowser</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>isExpiringSoon</code> check uses a 5-minute buffer (<code>TOKEN_REFRESH_BUFFER_MS = 300_000</code>). If your token expires in 4 minutes, the refresh happens proactively rather than failing mid-upload. This is important because session publishing involves a multi-step sequence (upload, then poll for processing) and a token that expires between those steps would leave the session in a partially-published state.</p><p>Tokens are persisted to <code>~/.claudebin/config.json</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>saveConfig</span>(<span style=color:#a6e22e>tokens</span>: <span style=color:#66d9ef>AuthTokens</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>dir</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>join</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>homedir</span>(), <span style=color:#e6db74>&#34;.claudebin&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>mkdirSync</span>(<span style=color:#a6e22e>dir</span>, { <span style=color:#a6e22e>recursive</span>: <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>mode</span>: <span style=color:#66d9ef>0o700</span> });
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>writeFileSync</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>join</span>(<span style=color:#a6e22e>dir</span>, <span style=color:#e6db74>&#34;config.json&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>tokens</span>),
</span></span><span style=display:flex><span>    { <span style=color:#a6e22e>mode</span>: <span style=color:#66d9ef>0o600</span> }
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>0o700</code> directory permission and <code>0o600</code> file permission restrict access to the current user only. This is the same pattern SSH uses for <code>~/.ssh/</code>. On macOS and Linux, this prevents other users on a shared machine from reading your tokens. On Windows, these permissions are effectively ignored. <code>fs.writeFileSync</code> doesn&rsquo;t enforce POSIX permissions on NTFS. A more robust Windows implementation would use ACLs via <code>icacls</code>, but that&rsquo;s outside claudebin&rsquo;s scope for now.</p><p>The access token TTL is 1 hour. The refresh token has a longer lifetime (server-configured). If the refresh token is also expired or revoked, the full browser flow triggers again. In practice, most users hit Tier 1 (cached token) for weeks before needing a refresh.</p><h2 id=generic-polling-with-typed-callbacks>Generic Polling with Typed Callbacks</h2><p>Both auth and session publishing use async polling. The backend processes sessions asynchronously (parsing JSONL, rendering syntax-highlighted HTML, generating metadata), and the client needs to wait. Rather than duplicate the retry logic, claudebin uses a generic <code>poll&lt;T>()</code> utility parameterized over the result type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>PollOptions</span>&lt;<span style=color:#f92672>T</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fn</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>T</span> <span style=color:#960050;background-color:#1e0010>|</span> <span style=color:#a6e22e>null</span>&gt;;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>isReady</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>result</span>: <span style=color:#66d9ef>T</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>result</span> <span style=color:#66d9ef>is</span> <span style=color:#a6e22e>T</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>interval</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>timeout</span>: <span style=color:#66d9ef>number</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>timeoutError</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>poll</span>&lt;<span style=color:#f92672>T</span>&gt;(<span style=color:#a6e22e>opts</span>: <span style=color:#66d9ef>PollOptions</span>&lt;<span style=color:#f92672>T</span>&gt;)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>T</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>deadline</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>() <span style=color:#f92672>+</span> <span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>timeout</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (Date.<span style=color:#a6e22e>now</span>() <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>deadline</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>fn</span>();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>isReady</span>(<span style=color:#a6e22e>result</span>)) <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Transient network errors: retry silently
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// Fatal errors (4xx): fn should throw a non-retryable error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Promise</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>interval</span>));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>timeoutError</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>isReady</code> callback uses a TypeScript type guard (<code>result is T</code>). This narrows the return type so callers get <code>T</code>, not <code>T | null</code>. The two polling sites configure different parameters:</p><table><thead><tr><th>Use case</th><th>Interval</th><th>Timeout</th><th>Rationale</th></tr></thead><tbody><tr><td>Auth completion</td><td>2s</td><td>5min</td><td>User may be slow logging in, typing 2FA</td></tr><tr><td>Session processing</td><td>2s</td><td>2min</td><td>Backend parsing shouldn&rsquo;t take longer</td></tr></tbody></table><p>The error handling inside the loop is intentionally coarse. Network errors (DNS failure, connection reset, 502) are swallowed and retried. The next poll attempt will likely succeed. This is a pragmatic choice: distinguishing transient from fatal errors in a <code>fetch()</code> call is surprisingly complex (is a 500 transient or permanent? depends on the backend). The timeout acts as the safety net.</p><p>There&rsquo;s no backoff. The 2-second fixed interval means claudebin generates at most 30 requests/minute against the backend during a poll. For a single-user CLI tool, this is negligible. A client library serving thousands of concurrent users would need exponential backoff with jitter, but that&rsquo;s a different problem.</p><h3 id=why-not-websockets>Why Not WebSockets?</h3><p>WebSockets would eliminate the polling latency entirely. The backend pushes a notification when processing is complete. But they introduce:</p><ol><li><strong>Connection lifecycle management.</strong> Heartbeats, reconnection, state synchronization after disconnect.</li><li><strong>Infrastructure complexity.</strong> WebSocket connections are stateful. Load balancers need sticky sessions or a pub/sub layer (Redis, NATS).</li><li><strong>Client complexity.</strong> The MCP server would need to maintain a persistent WebSocket alongside the stdio event loop.</li></ol><p>For a flow where the user waits 5-15 seconds, adding 0-2 seconds of polling overhead doesn&rsquo;t justify the architectural cost. The polling implementation is 20 lines. A robust WebSocket client is 200+.</p><h2 id=the-indirection-problem-why-this-architecture-frustrates-me>The Indirection Problem: Why This Architecture Frustrates Me</h2><p>Let me be honest about the developer experience. Here&rsquo;s what happens when a user types <code>/claudebin:share</code> in Claude Code:</p><pre tabindex=0><code>User types &#34;/claudebin:share&#34;
  → Claude reads commands/share.md (a markdown file with YAML frontmatter)
  → Markdown body becomes instructions injected into Claude&#39;s context
  → Claude interprets the instructions and decides to call the MCP tool
  → Claude constructs a tools/call JSON-RPC message
  → Message is serialized, newline-terminated, written to the child process&#39;s stdin
  → MCP SDK deserializes, validates against Zod schema, dispatches to handler
  → Handler runs, returns result
  → Result serialized back over stdout as JSON-RPC response
  → Claude reads the response and formats it for the user
</code></pre><p>That&rsquo;s <strong>four layers of indirection</strong> between &ldquo;user wants to share&rdquo; and &ldquo;code runs.&rdquo; A markdown file instructs an LLM to construct a JSON-RPC message to send over stdio to a child process that validates it with Zod before executing a function.</p><p>Compare this to how OpenCode (the platform <a href=https://github.com/vtemian/micode>micode</a> extends) handles the same concept:</p><pre tabindex=0><code>User types &#34;/init&#34;
  → Command config maps &#34;/init&#34; to agent &#34;project-initializer&#34; with a template
  → Agent receives the template as a prompt
  → Agent calls tools directly via typed function dispatch
</code></pre><p>In OpenCode, a tool is a TypeScript function registered in-process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>tool</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#34;@opencode-ai/plugin/tool&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ast_grep_search</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tool</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>description</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Search code patterns using AST-aware matching&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>args</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pattern</span>: <span style=color:#66d9ef>tool.schema.string</span>().<span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#34;AST pattern&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lang</span>: <span style=color:#66d9ef>tool.schema.enum</span>(<span style=color:#a6e22e>LANGUAGES</span>).<span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#34;Target language&#34;</span>),
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>execute</span>: <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>args</span>, <span style=color:#a6e22e>context</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>runSg</span>(<span style=color:#a6e22e>args</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>formatMatches</span>(<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>matches</span>);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>No IPC. No serialization boundary. No child process. The tool runs in the same process as the agent, with full access to the <code>ToolContext</code> (session ID, abort signals, permission prompts). The agent calls the tool, the tool returns a string. One hop.</p><p>Commands map directly to agents with a template:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>command</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>init</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>description</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Initialize project&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>agent</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;project-initializer&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`Initialize this project. $ARGUMENTS`</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>No intermediate markdown file that an LLM has to interpret. No hope that the model correctly infers <code>project_path</code> from context. The routing is deterministic.</p><h3 id=where-mcp-pays-its-indirection-tax>Where MCP Pays Its Indirection Tax</h3><p>The cost of MCP&rsquo;s architecture shows up in specific, concrete ways:</p><p><strong>Debugging is painful.</strong> When your tool doesn&rsquo;t receive the right arguments, you have to figure out which layer failed. Did Claude misinterpret the slash command markdown? Did it construct the wrong arguments? Did the JSON-RPC serialization lose something? Did Zod reject a valid input? Each layer has its own failure mode, and <code>console.log</code> goes to stderr (not stdout, remember, stdout is the JSON-RPC channel). You end up writing to a debug file and tailing it in another terminal.</p><p><strong>Latency is visible.</strong> The LLM has to reason about which tool to call, construct the arguments, and generate the JSON. All of which costs tokens and time. In OpenCode, tool dispatch is a function lookup in a hash map. In MCP, it&rsquo;s an LLM inference step. For claudebin&rsquo;s single-tool use case, this overhead is ~1-2 seconds of model thinking time before the actual work starts.</p><p><strong>State sharing is impossible.</strong> Each MCP server runs in its own process. If two MCP tools need to share state (say, an auth token) they can&rsquo;t. They have to go through the filesystem or an external service. OpenCode plugins run in-process and share the plugin context object directly.</p><p><strong>Error recovery depends on the model.</strong> If an MCP tool returns <code>isError: true</code>, Claude has to decide what to do. Maybe it retries. Maybe it tells the user. Maybe it hallucinates a workaround. In OpenCode, error handling is programmatic. The agent&rsquo;s prompt can include explicit retry logic, or the tool can throw a typed error that the orchestrator catches.</p><h3 id=where-mcp-earns-its-keep>Where MCP Earns Its Keep</h3><p>There&rsquo;s no silver bullet, and MCP&rsquo;s indirection buys real things:</p><p><strong>Language agnosticism.</strong> Claudebin is TypeScript. My <a href=https://github.com/vtemian/dd/tree/main/tools/booking-mcp>booking-mcp</a> server is Python with Playwright. My <a href=https://github.com/vtemian/dd/tree/main/tools/whoop-mcp>whoop-mcp</a> server is also Python. MCP doesn&rsquo;t care. If it speaks JSON-RPC over stdio, it works. OpenCode plugins must be JavaScript/TypeScript compiled for Bun. If your tool needs Python (ML inference, browser automation with Playwright, scientific computing), you&rsquo;re wrapping it in a subprocess anyway.</p><p><strong>Process isolation.</strong> An MCP server that crashes doesn&rsquo;t take down Claude Code. A segfaulting native module in an OpenCode plugin kills the entire process. For tools that do dangerous things (browser automation, shell execution, network scraping), isolation isn&rsquo;t overhead. It&rsquo;s a feature.</p><p><strong>Ecosystem portability.</strong> An MCP server works with Claude Code, Cursor, Windsurf, Zed, and any other client that implements the protocol. An OpenCode plugin works with OpenCode. I&rsquo;ve shipped 3 MCP servers that work across editors. That portability has real value.</p><p><strong>Composability without coordination.</strong> Claude can orchestrate multiple MCP tools from different authors without those tools knowing about each other. The LLM acts as the integration layer. In OpenCode, composing tools across plugins requires the plugin authors to agree on interfaces, or the orchestrator agent needs explicit knowledge of each tool&rsquo;s behavior.</p><h3 id=the-honest-assessment>The Honest Assessment</h3><p>MCP is the right choice when you&rsquo;re building tools for a broad ecosystem and you value portability over performance. It&rsquo;s the wrong choice when you&rsquo;re building a tightly integrated agent system where latency, state sharing, and deterministic dispatch matter.</p><p>I&rsquo;ve shipped MCP servers and OpenCode plugins. The MCP developer experience is worse for simple tools. Too much ceremony, too many layers. But for tools that need to work everywhere and can&rsquo;t assume a specific runtime, it&rsquo;s the only game in town.</p><p>The real question is whether the industry converges on MCP as the universal standard (like LSP did for language servers) or whether competing plugin models fragment the ecosystem. Right now, Anthropic&rsquo;s push for MCP has momentum. But if I&rsquo;m building a tool that only needs to work in one editor, I&rsquo;d skip MCP and go direct every time.</p><h2 id=bundling-zero-install-distribution>Bundling: Zero-Install Distribution</h2><p>MCP servers need to work on any machine with Claude Code installed. You can&rsquo;t assume the user has run <code>npm install</code> or even has your dependencies available. Claudebin solves this by bundling everything into a single JavaScript file using tsup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// tsup.config.ts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#a6e22e>defineConfig</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#34;src/index.ts&#34;</span>],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>format</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#34;esm&#34;</span>],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>target</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;es2022&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>noExternal</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>/.*/</span>],  <span style=color:#75715e>// Bundle ALL dependencies
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span></code></pre></div><p>The <code>noExternal: [/.*/]</code> regex tells tsup to inline every dependency (the MCP SDK, Zod, and all transitive dependencies) into a single output file. The result is a self-contained <code>dist/index.js</code> that runs with <code>node dist/index.js</code> and nothing else.</p><p>This matters because the alternative is shipping a <code>node_modules</code> directory (or requiring the user to <code>npm install</code>). The MCP SDK alone pulls in <code>content-type</code>, <code>raw-body</code>, <code>eventsource</code>, and several other packages. Bundling eliminates version conflicts between plugins. If two MCP servers depend on different Zod versions, they each have their own copy inlined.</p><p>The trade-off: the bundle is larger (~200KB vs ~15KB of source). And tree-shaking doesn&rsquo;t help much because the MCP SDK&rsquo;s module structure doesn&rsquo;t support dead code elimination well. You&rsquo;re shipping the full SDK even though claudebin only uses <code>McpServer</code> and <code>StdioServerTransport</code>.</p><p>The <code>.mcp.json</code> file tells Claude Code how to spawn the server:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;mcpServers&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;claudebin&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;command&#34;</span>: <span style=color:#e6db74>&#34;node&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;args&#34;</span>: [<span style=color:#e6db74>&#34;dist/index.js&#34;</span>],
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;stdio&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Claude Code reads this on startup, spawns <code>node dist/index.js</code> as a child process, connects stdin/stdout pipes, and sends the <code>initialize</code> handshake. The <code>type: "stdio"</code> is currently the only supported transport for local MCP servers. HTTP-based transports exist in the spec but aren&rsquo;t used by Claude Code for plugins.</p><p>Compare this to OpenCode&rsquo;s distribution model: plugins are npm packages loaded at runtime via Bun&rsquo;s module resolution. <code>"plugin": ["micode"]</code> in the config triggers <code>import("micode")</code>. No bundling needed. Bun resolves the package from <code>node_modules</code>. The downside is you need <code>npm install</code> or <code>bun add</code> as a setup step. The upside is you get proper tree-shaking, shared dependencies, and hot-reloading during development.</p><h2 id=slash-commands-llm-as-dispatch-layer>Slash Commands: LLM as Dispatch Layer</h2><p>MCP tools are powerful but not discoverable. Users don&rsquo;t know what tools exist unless they ask Claude or read docs. Slash commands bridge this gap, but the way they work reveals a fundamental architectural choice.</p><p>Claudebin registers <code>/claudebin:share</code> through a markdown file in the <code>commands/</code> directory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>share</span>
</span></span><span style=display:flex><span><span style=color:#f92672>description</span>: <span style=color:#ae81ff>Share the current session to claudebin.com</span>
</span></span><span style=display:flex><span><span style=color:#f92672>allowed-tools</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>mcp</span>: <span style=color:#ae81ff>claudebin</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>Share the current Claude Code session to Claudebin.</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>Authenticates automatically if needed.</span>
</span></span></code></pre></div><p>The YAML frontmatter defines command metadata and permissions. The <code>allowed-tools</code> field is a security boundary. It restricts which MCP tools this command can invoke, preventing the markdown body from instructing Claude to call arbitrary tools.</p><p>The markdown body is the interesting part. It&rsquo;s not a function call. It&rsquo;s not a routing directive. It&rsquo;s <strong>natural language instructions injected into Claude&rsquo;s context</strong>. When the user types <code>/claudebin:share</code>, Claude reads this markdown and decides, through inference, to call the <code>share</code> MCP tool with the current project path.</p><p>This means the &ldquo;dispatch&rdquo; is non-deterministic. Claude usually gets it right, but the path from slash command to tool invocation goes through the model&rsquo;s reasoning. If the instructions are ambiguous, Claude might ask clarifying questions instead of calling the tool. If the model is having a bad day, it might pass the wrong arguments.</p><p>OpenCode&rsquo;s command system is deterministic:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>init</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>description</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Initialize project&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>agent</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;project-initializer&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`Initialize this project. $ARGUMENTS`</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>/init</code> always routes to <code>project-initializer</code>. Always. The template is filled with <code>$ARGUMENTS</code> via string substitution, not LLM inference. The agent receives the prompt and runs. There&rsquo;s no intermediate interpretation step.</p><p>The trade-off: Claude Code&rsquo;s approach is more flexible. A slash command can orchestrate complex multi-tool workflows through natural language instructions without writing routing code. OpenCode&rsquo;s approach is more reliable. The mapping from command to agent is a direct lookup, not a model inference. For a single-tool plugin like claudebin, the flexibility is wasted. For a hypothetical plugin that needs to conditionally call different tools based on project state, Claude&rsquo;s interpretation layer would shine.</p><h2 id=what-id-do-differently>What I&rsquo;d Do Differently</h2><p><strong>Add tests from day one.</strong> The codebase is 600 lines of TypeScript with zero tests. For a v1 that shipped quickly, that was a conscious trade-off. But the path normalization logic, token lifecycle management, and file filtering are all pure functions that are trivial to unit test and painful to debug in production. The first bug report I got was a path normalization edge case on Windows. Tests would have caught it.</p><p><strong>Consider streaming for large sessions.</strong> The current approach reads the entire session into a V8 string, which means ~2x the file size in heap due to UTF-16 encoding. A <code>ReadableStream</code> piped through a multipart upload would handle arbitrarily large sessions with constant memory. The backend already accepts chunked transfers.</p><p><strong>Build a local preview.</strong> Right now, you publish to see what your session looks like rendered. A local preview mode (even just a <code>localhost:3000</code> server that renders the JSONL) would tighten the feedback loop significantly.</p><p><strong>Abstract the polling into a cancellable operation.</strong> The current <code>poll()</code> doesn&rsquo;t support cancellation. If the user hits Ctrl+C during a 5-minute auth timeout, the process exits uncleanly. An <code>AbortController</code> integration would let the polling loop respond to signals gracefully.</p><h2 id=the-takeaway-600-lines-four-layers-one-url>The Takeaway: 600 Lines, Four Layers, One URL</h2><p>The entire claudebin MCP server is ~600 lines of TypeScript across 8 files. It handles device authorization, session extraction from an undocumented local format, async publishing with typed polling, and cross-platform URL opening. The MCP SDK handles the protocol plumbing (JSON-RPC framing, capability negotiation, schema generation) so your code focuses on domain logic.</p><p>But those 600 lines sit inside an architecture that&rsquo;s both impressive and frustrating. MCP gives you language-agnostic tool definition, process isolation, and cross-editor portability. It also gives you four layers of indirection, non-deterministic dispatch, and a debugging experience that makes you miss <code>console.log</code>.</p><p>I&rsquo;ve shipped 3 MCP servers (claudebin, <a href=https://github.com/vtemian/dd/tree/main/tools/booking-mcp>booking-mcp</a>, <a href=https://github.com/vtemian/dd/tree/main/tools/whoop-mcp>whoop-mcp</a>) and an <a href=https://github.com/vtemian/micode>OpenCode plugin</a> with 22 agents and direct tool dispatch. Both models work. MCP wins on portability and isolation. Direct plugins win on latency, debuggability, and developer experience.</p><p>If you&rsquo;re building a tool that needs to work across Claude Code, Cursor, and Zed, MCP is the right choice. The ceremony is the price of admission. If you&rsquo;re building for a single platform and you want tight integration with the agent runtime, skip the protocol layer and go direct.</p><p>MCP is to agent tooling what REST was to web services in 2008. It&rsquo;s not perfect. It&rsquo;s verbose. The indirection feels unnecessary for simple cases. But it&rsquo;s becoming the standard, and building against a standard, even an imperfect one, compounds over time.</p><p>The code is open source at <a href=https://github.com/wunderlabs-dev/claudebin>github.com/wunderlabs-dev/claudebin</a>. If you&rsquo;re building your own MCP plugin, steal whatever&rsquo;s useful.</p><p>Stay curious ☕</p></p></article></main><script>hljs.initHighlightingOnLoad()</script><footer class=footer>&copy; 2026 <a href=https://github.com/vtemian>Vlad Temian</a>,
powered by <a href=https://gohugo.io/ target=_blank>Hugo</a>,
with help from <a href=https://github.com/balajmarius>&copy;balajmarius</a>.</footer></div></body></html>