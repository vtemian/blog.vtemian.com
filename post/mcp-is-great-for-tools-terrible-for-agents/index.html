<!doctype html><html lang=en><head><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,minimum-scale=1"><link rel=preconnect href=https://cdn.jsdelivr.net crossorigin><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/geist@1/dist/fonts/geist-sans/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/geist@1/dist/fonts/geist-mono/style.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tokyo-night-dark.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js></script><script>hljs.highlightAll()</script><meta charset=utf-8><meta name=robots content="index,follow"><link rel=canonical href=https://blog.vtemian.com/post/mcp-is-great-for-tools-terrible-for-agents/><link rel=icon type=image/svg+xml href=https://blog.vtemian.com/favicon.svg><link rel=apple-touch-icon href=https://blog.vtemian.com/favicon.svg><meta name=keywords content="mcp,model context protocol,claude code plugin,mcp server,json-rpc,claudebin,opencode,agentic programming"><meta name=description content="Building claudebin as an MCP server for Claude Code. JSON-RPC protocol, session extraction, device auth, and an honest comparison with OpenCode's plugin model."><meta property="og:url" content="https://blog.vtemian.com/post/mcp-is-great-for-tools-terrible-for-agents/"><meta property="og:site_name" content="Vlad Temian - Centrist Tech Optimist"><meta property="og:title" content="MCP Is Great for Tools. Terrible for Agents."><meta property="og:description" content="Building claudebin as an MCP server for Claude Code. JSON-RPC protocol, session extraction, device auth, and an honest comparison with OpenCode's plugin model."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:published_time" content="2026-02-27T10:00:00+02:00"><meta property="article:modified_time" content="2026-02-27T10:00:00+02:00"><meta property="article:tag" content="Mcp"><meta property="article:tag" content="Agentic-Programming"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Deep-Dive"><meta property="og:image" content="https://blog.vtemian.com/post/mcp-is-great-for-tools-terrible-for-agents/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="MCP Is Great for Tools. Terrible for Agents."><meta name=twitter:description content="Building claudebin as an MCP server for Claude Code. JSON-RPC protocol, session extraction, device auth, and an honest comparison with OpenCode's plugin model."><meta name=twitter:image content="https://blog.vtemian.com/post/mcp-is-great-for-tools-terrible-for-agents/og.png"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.vtemian.com\/post\/mcp-is-great-for-tools-terrible-for-agents\/"},"headline":"MCP Is Great for Tools. Terrible for Agents.","description":"Building claudebin as an MCP server for Claude Code. JSON-RPC protocol, session extraction, device auth, and an honest comparison with OpenCode\u0027s plugin model.","inLanguage":"en-US","author":{"@type":"Person","name":"Vlad Temian","url":"https:\/\/blog.vtemian.com\/","sameAs":["https://github.com/vtemian","https://linkedin.com/in/vtemian","https://x.com/vtemian"]},"publisher":{"@type":"Person","name":"Vlad Temian"},"datePublished":"2026-02-27T10:00:00\u002b02:00","dateModified":"2026-02-27T10:00:00\u002b02:00","url":"https:\/\/blog.vtemian.com\/post\/mcp-is-great-for-tools-terrible-for-agents\/","wordCount":1769,"timeRequired":"PT9M","keywords":["mcp","agentic-programming","typescript","deep-dive"]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/blog.vtemian.com\/"},{"@type":"ListItem","position":2,"name":"Post","item":"https:\/\/blog.vtemian.com\/post/"},{"@type":"ListItem","position":3,"name":"MCP Is Great for Tools. Terrible for Agents.","item":"https:\/\/blog.vtemian.com\/post\/mcp-is-great-for-tools-terrible-for-agents\/"}]}</script><title>MCP Is Great for Tools. Terrible for Agents.</title>
<link rel=stylesheet href=https://blog.vtemian.com/stylesheets/main.min.1398275a342c56d8d677f01e4a41c3607637246bc49821d8d08bda5acc0873e7.css media=screen><meta name=google-site-verification content="2qk_e0y84NNSVpaorKgeNURYF9Ni3UyJvPq9GZdGEgs"></head><body class="bg-bg text-ink font-sans text-sm leading-relaxed antialiased"><div class="max-w-2xl mx-auto py-12 px-5 flex flex-col gap-12"><a href=https://blog.vtemian.com/ class="font-mono text-xs text-muted tracking-wide">Back to home</a><article class="flex flex-col gap-12"><header><h1 class=text-2xl>MCP Is Great for Tools. Terrible for Agents.</h1><p class="text-link text-xs">February 2026</p></header><div class="flex flex-col gap-4"><p>Claude Code sessions live as <code>.jsonl</code> files under <code>~/.claude/projects/</code>. They&rsquo;re ephemeral. You debug a race condition, the agent rewrites three files, and then it&rsquo;s gone. <a href=https://claudebin.com>Claudebin</a> turns any session into a shareable URL. Run <code>/claudebin:share</code>, get back a permanent link.</p><p>This post is about what&rsquo;s underneath. Building an MCP server, shipping it as a Claude Code plugin, and where the architecture shines vs where it falls apart.</p><p><strong>TL;DR</strong></p><ul><li>MCP is JSON-RPC 2.0 over stdio. Your plugin is a child process that Claude Code pipes JSON to. Simple, isolated, language-agnostic.</li><li>Claude Code&rsquo;s slash commands are non-deterministic. A markdown file instructs the LLM to call your tool. The dispatch goes through model reasoning. It works. Usually.</li><li><code>console.log</code> in an MCP server corrupts the JSON-RPC stream. You will learn this the hard way.</li><li>Claude Code plugins can&rsquo;t observe, intercept, or modify agent behavior. No lifecycle hooks. You get a pipe and a schema. That&rsquo;s it.</li><li>OpenCode plugins run in-process with 11+ hooks, shared state, and deterministic dispatch. The DX is better. The portability is worse.</li><li>MCP is the right model for tools. OpenCode&rsquo;s model is the right one for agent systems. Claude Code only offers MCP. If you need more than a simple tool, you&rsquo;re fighting the architecture.</li><li>The ideal platform would offer both. Neither does that today.</li></ul><h2 id=mcp-json-rpc-20-over-stdio>MCP: JSON-RPC 2.0 Over stdio</h2><p>The <a href=https://modelcontextprotocol.io/>Model Context Protocol</a> sits on top of JSON-RPC 2.0 <sup><a href=#ref-1>[1]</a></sup>. Claude Code spawns your server as a child process, pipes stdin/stdout, and exchanges newline-delimited JSON <sup><a href=#ref-2>[2]</a></sup>. No HTTP, no WebSockets, no port allocation. One child process per MCP server, lifecycle tied to the parent <sup><a href=#ref-2>[2]</a></sup>.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    CC[Claude Code] --&gt;|stdin: JSON-RPC| MCP[MCP Server process]
    MCP --&gt;|stdout: JSON-RPC| CC
    CC --&gt;|stdin: JSON-RPC| MCP2[Another MCP Server]
    MCP2 --&gt;|stdout: JSON-RPC| CC
</code></pre><p>When Claude Code starts your server, it sends an <code>initialize</code> request:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>→</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>1</span>,<span style=color:#f92672>&#34;method&#34;</span>:<span style=color:#e6db74>&#34;initialize&#34;</span>,<span style=color:#f92672>&#34;params&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;protocolVersion&#34;</span>:<span style=color:#e6db74>&#34;2025-11-25&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;capabilities&#34;</span>:{<span style=color:#f92672>&#34;roots&#34;</span>:{<span style=color:#f92672>&#34;listChanged&#34;</span>:<span style=color:#66d9ef>true</span>}},
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;clientInfo&#34;</span>:{<span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;claude-code&#34;</span>,<span style=color:#f92672>&#34;version&#34;</span>:<span style=color:#e6db74>&#34;1.0.0&#34;</span>}}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>←</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>1</span>,<span style=color:#f92672>&#34;result&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;protocolVersion&#34;</span>:<span style=color:#e6db74>&#34;2025-11-25&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;capabilities&#34;</span>:{<span style=color:#f92672>&#34;tools&#34;</span>:{}},
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;serverInfo&#34;</span>:{<span style=color:#f92672>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;claudebin&#34;</span>,<span style=color:#f92672>&#34;version&#34;</span>:<span style=color:#e6db74>&#34;1.0.0&#34;</span>}}}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>→</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;method&#34;</span>:<span style=color:#e6db74>&#34;notifications/initialized&#34;</span>}
</span></span></code></pre></div><p>Capability negotiation <sup><a href=#ref-3>[3]</a></sup>. The client declares what it supports, the server responds with its own. Claudebin only declares <code>tools</code>. The third message is a notification (no <code>id</code>, no response expected), signaling the handshake is complete.</p><p>Then Claude discovers tools via <code>tools/list</code> and invokes them via <code>tools/call</code> <sup><a href=#ref-4>[4]</a></sup>. The tool response uses MCP&rsquo;s content block format:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>←</span> {<span style=color:#f92672>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#f92672>&#34;id&#34;</span>:<span style=color:#ae81ff>3</span>,<span style=color:#f92672>&#34;result&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;content&#34;</span>:[{<span style=color:#f92672>&#34;type&#34;</span>:<span style=color:#e6db74>&#34;text&#34;</span>,<span style=color:#f92672>&#34;text&#34;</span>:<span style=color:#e6db74>&#34;https://claudebin.com/threads/abc123&#34;</span>}]}}
</span></span></code></pre></div><p>MCP separates <em>protocol errors</em> (unknown tools, malformed requests, server failures) from <em>tool errors</em> (your code ran but failed). Tool errors return a successful response with <code>isError: true</code> <sup><a href=#ref-4>[4]</a></sup>. The distinction matters because Claude can reason about tool errors and retry. Protocol errors rarely lead to successful recovery.</p><p>One gotcha with the long-lived process model: <code>console.log</code> goes to stdout and corrupts the JSON-RPC stream <sup><a href=#ref-2>[2]</a></sup>. This bites every new MCP developer. Use <code>console.error</code> for debugging.</p><h2 id=session-extraction>Session Extraction</h2><p>The genuinely hard part of claudebin is figuring out where Claude stores sessions and extracting the right one.</p><p>Sessions are <code>.jsonl</code> files under <code>~/.claude/projects/</code>. The directory name is a normalized project path. <code>/Users/vlad/projects/my-app</code> becomes <code>-Users-vlad-projects-my-app</code>. Every non-alphanumeric character (including the leading slash) maps to a dash. One regex, one pass:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>normalizeProjectPath</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>projectPath</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>projectPath</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>/[^a-zA-Z0-9]/g</span>, <span style=color:#e6db74>&#34;-&#34;</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This is undocumented. I found it by reading Claude Code&rsquo;s source <sup><a href=#ref-5>[5]</a></sup> and verifying against the filesystem. Getting it wrong means a silent &ldquo;session not found&rdquo; error.</p><p>The directory contains multiple files:</p><pre tabindex=0><code>~/.claude/projects/Users-vlad-projects-my-app/
├── default.jsonl          # Main conversation
├── agent-a1b2c3d4.jsonl   # Subagent session (Task tool)
├── agent-e5f6g7h8.jsonl   # Another subagent
</code></pre><p>Claudebin filters out <code>agent-*</code> files and picks the most recent by <code>mtime</code>. Each JSONL line is a self-contained message object (user message, assistant response, tool call, tool result). The file is read as a UTF-8 string and sent as-is to the backend for rendering.</p><p>The memory trade-off: Node.js strings are UTF-16 internally <sup><a href=#ref-6>[6]</a></sup>, so a 50MB session becomes ~100MB of heap. Add JSON serialization for the HTTP body and you hit ~200MB peak. A streaming upload would fix this, but for typical sessions (100KB-5MB) it wasn&rsquo;t worth the complexity. The 50MB limit is a client-side safety valve.</p><h2 id=device-authorization>Device Authorization</h2><p>MCP servers run in a terminal. No browser window, no OAuth redirect URI. Claudebin uses a pattern similar to RFC 8628 (Device Authorization Grant) <sup><a href=#ref-7>[7]</a></sup>:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant P as Plugin
    participant B as Backend
    participant Br as Browser

    P-&gt;&gt;B: POST /api/auth/start
    B--&gt;&gt;P: { code, authUrl }
    P-&gt;&gt;Br: exec(&#34;open&#34;, authUrl)
    Br-&gt;&gt;B: User logs in via OAuth
    B-&gt;&gt;B: Mark code as verified
    loop Every 2s, up to 5min
        P-&gt;&gt;B: GET /api/auth/poll?code=abc
    end
    B--&gt;&gt;P: { accessToken, refreshToken, expiresAt }
</code></pre><p>The one-time code correlates the CLI and browser session. Tokens are cached in <code>~/.claudebin/config.json</code> with <code>0o600</code> permissions <sup><a href=#ref-5>[5]</a></sup> (same pattern as <code>~/.ssh/</code>). Before every share, claudebin checks the cached token. If it&rsquo;s within 5 minutes of expiry, it refreshes proactively rather than failing mid-upload.</p><p>Both auth and session publishing use async polling. Rather than duplicate the retry logic, claudebin has a generic <code>poll&lt;T>()</code> with configurable interval, timeout, and a type guard callback. Auth polls for 5 minutes (user might be slow). Session processing polls for 2 minutes. No backoff, fixed 2-second interval. For a single-user CLI tool generating 30 req/min during a poll, this is fine.</p><p>Why not WebSockets? Connection lifecycle management, stateful load balancing, maintaining a persistent socket alongside the stdio event loop. The polling implementation is 20 lines. A robust WebSocket client is 200+. For a 5-15 second wait, 2 seconds of overhead is acceptable.</p><h2 id=two-plugin-models-two-philosophies>Two Plugin Models, Two Philosophies</h2><p>I&rsquo;ve also built <a href=https://github.com/vtemian/micode>micode</a>, a plugin for <a href=https://opencode.ai/>OpenCode</a> with 26 specialized agents. The experience of building for both platforms exposed a fundamental design disagreement about what a &ldquo;plugin&rdquo; should be.</p><p>In Claude Code, a plugin is a separate process that the LLM talks to over a protocol. In OpenCode, a plugin is code that runs inside the agent runtime. This isn&rsquo;t a minor implementation detail. It shapes everything.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TD
    U1[&#34;User: /share&#34;] --&gt; MD[&#34;Markdown file&#34;] --&gt; LLM[&#34;LLM interprets&#34;] --&gt; RPC[&#34;JSON-RPC over stdio&#34;] --&gt; ZOD[&#34;Zod validates&#34;] --&gt; FN1[&#34;Handler runs&#34;]
    U2[&#34;User: /init&#34;] --&gt; CFG[&#34;Config lookup&#34;] --&gt; AGT[&#34;Agent receives prompt&#34;] --&gt; FN2[&#34;Tool executes&#34;]

    style U1 fill:#f9f,stroke:#333
    style U2 fill:#bbf,stroke:#333
    style FN1 fill:#f9f,stroke:#333
    style FN2 fill:#bbf,stroke:#333
</code></pre><p>The left chain (pink) is Claude Code: 6 hops. The right chain (blue) is OpenCode: 4 hops.</p><h3 id=dispatch-deterministic-vs-probabilistic>Dispatch: Deterministic vs Probabilistic</h3><p>When you type <code>/claudebin:share</code> in Claude Code, the slash command is a markdown file. Claude reads it, interprets the natural language instructions, and <em>decides</em> to call the MCP tool. The dispatch goes through model reasoning. It&rsquo;s probabilistic. Claude usually gets it right. Usually.</p><p>When you type <code>/init</code> in OpenCode, a config object maps the command to an agent:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>command</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>init</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>agent</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;project-initializer&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>`Initialize this project. $ARGUMENTS`</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>String substitution. Hash map lookup. Deterministic. <code>/init</code> always routes to <code>project-initializer</code>. There is no interpretation step.</p><p>For claudebin, a single-tool plugin, this means Claude spends 1-2 seconds reasoning about which tool to call when there&rsquo;s only one option. That&rsquo;s model inference time burned on a decision with exactly one valid answer.</p><h3 id=hooks-observing-vs-hoping>Hooks: Observing vs Hoping</h3><p>This is where the gap gets wide. OpenCode plugins have lifecycle hooks. You can intercept and modify behavior at 11+ points: before/after tool execution, on message receive, on context compaction, on permission prompts.</p><p>In micode, the <code>tool.execute.after</code> hook truncates tool output to stay within context limits. The <code>chat.params</code> hook injects project context files before each LLM call. The <code>experimental.chat.system.transform</code> hook modifies the system prompt dynamically based on what the agent is doing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;tool.execute.after&#34;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>output</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>tokenAwareTruncation</span>(<span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>output</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>artifactAutoIndex</span>(<span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>output</span>);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;chat.params&#34;</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>output</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>injectProjectContext</span>(<span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>output</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>loadContinuityLedger</span>(<span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>output</span>);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Claude Code plugins can&rsquo;t do any of this. Your MCP server is a black box behind a pipe. You get a request, you return a response. You can&rsquo;t observe what Claude is doing, intercept other tools, modify the system prompt, or react to session events. You can&rsquo;t even know how much context is left.</p><p>This matters in practice. Micode tracks file operations across tool calls and auto-indexes artifacts. It detects when context is running low and triggers a ledger dump. It enforces code style patterns by injecting constraints into the system prompt. None of this is possible through MCP. You&rsquo;d have to rely on Claude&rsquo;s built-in behavior and hope it does the right thing.</p><h3 id=state-shared-vs-isolated>State: Shared vs Isolated</h3><p>OpenCode plugins share the runtime. Tools access a <code>ToolContext</code> with session ID and abort signals. Shared state lives in closures over the plugin scope. One tool can read what another tool wrote. Agents spawn subagents via <code>spawn_agent</code>, which creates fresh sessions but receives context explicitly through the prompt.</p><p>MCP servers are isolated processes. If two tools need shared state, they go through the filesystem. There&rsquo;s no session context, no abort propagation, no shared memory. Claudebin manages its own auth state in <code>~/.claudebin/config.json</code> because there&rsquo;s nowhere else to put it.</p><p>For simple tools like claudebin, isolation is fine. You call one function, get one result. But for a system like micode where 26 agents coordinate, spawn subagents in parallel, share continuity ledgers, and track progress across tasks, process isolation would be a straitjacket.</p><h3 id=so-which-one-wins>So Which One Wins?</h3><p>Neither. They solve different problems.</p><table><thead><tr><th></th><th>MCP (Claude Code)</th><th>Direct Plugin (OpenCode)</th></tr></thead><tbody><tr><td>Tool dispatch</td><td>LLM inference</td><td>Hash map lookup</td></tr><tr><td>Lifecycle hooks</td><td>None</td><td>11+ hook points</td></tr><tr><td>State sharing</td><td>Filesystem only</td><td>In-process context</td></tr><tr><td>Language support</td><td>Any (JSON-RPC over stdio)</td><td>JS/TS only (Bun runtime)</td></tr><tr><td>Process isolation</td><td>Yes</td><td>No</td></tr><tr><td>Portability</td><td>Claude Code, Cursor, Zed</td><td>OpenCode only</td></tr><tr><td>Agent orchestration</td><td>Single agent, sequential</td><td>Multi-agent, parallel spawning</td></tr></tbody></table><p>MCP is the right model for tools. Standalone utilities that do one thing, work across editors, and benefit from isolation. A hotel scraper, a session sharer, a code search engine. Write it in any language, ship it everywhere.</p><p>OpenCode&rsquo;s model is the right one for agent systems. When you need hooks, state, parallel agents, deterministic routing, and deep integration with the runtime. When the plugin isn&rsquo;t a utility but a workflow engine.</p><p>The problem is that Claude Code only offers MCP. If you want to build anything beyond a simple tool, you&rsquo;re fighting the architecture. You can&rsquo;t observe, you can&rsquo;t intercept, you can&rsquo;t orchestrate. You get a pipe and a JSON schema.</p><p>OpenCode only offers direct plugins. If you want a Python tool, you&rsquo;re wrapping it in a subprocess yourself. If you want cross-editor portability, you&rsquo;re out of luck.</p><p>The ideal platform would offer both. MCP for portable tools, direct plugins for deep integration. Neither does that today.</p><p>The code is at <a href=https://github.com/wunderlabs-dev/claudebin>github.com/wunderlabs-dev/claudebin</a>.</p><p>Stay curious ☕</p><hr><p><strong>References</strong></p><p><a id=ref-1></a>[1] JSON-RPC 2.0 Specification -<a href=https://www.jsonrpc.org/specification>jsonrpc.org/specification</a></p><p><a id=ref-2></a>[2] MCP Specification: Transports -<a href=https://modelcontextprotocol.io/specification/2025-11-25/basic/transports>modelcontextprotocol.io/specification/2025-11-25/basic/transports</a></p><p><a id=ref-3></a>[3] MCP Specification: Lifecycle -<a href=https://modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle>modelcontextprotocol.io/specification/2025-11-25/basic/lifecycle</a></p><p><a id=ref-4></a>[4] MCP Specification: Tools -<a href=https://modelcontextprotocol.io/specification/2025-11-25/server/tools>modelcontextprotocol.io/specification/2025-11-25/server/tools</a></p><p><a id=ref-5></a>[5] Claudebin source code -<a href=https://github.com/wunderlabs-dev/claudebin>github.com/wunderlabs-dev/claudebin</a></p><p><a id=ref-6></a>[6] JavaScript&rsquo;s internal character encoding: UCS-2 or UTF-16? -<a href=https://mathiasbynens.be/notes/javascript-encoding>mathiasbynens.be/notes/javascript-encoding</a></p><p><a id=ref-7></a>[7] RFC 8628: OAuth 2.0 Device Authorization Grant -<a href=https://datatracker.ietf.org/doc/html/rfc8628>datatracker.ietf.org/doc/html/rfc8628</a></p></div></article><footer class="flex justify-between text-xs text-link"><span>&copy; 2026 <a href=https://github.com/vtemian>Vlad Temian</a></span>
<span>Order within chaos.</span></footer></div><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: false, theme: 'neutral' });
    
    document.querySelectorAll('code.language-mermaid').forEach(el => {
        const pre = el.parentElement;
        const div = document.createElement('pre');
        div.className = 'mermaid';
        div.textContent = el.textContent;
        pre.parentElement.replaceChild(div, pre);
    });
    await mermaid.run();
</script></body></html>