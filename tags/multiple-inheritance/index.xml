<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Multiple Inheritance on vtemian - blog</title><link>https://blog.vtemian.com/tags/multiple-inheritance/</link><description>Recent content in Multiple Inheritance on vtemian - blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 01 May 2020 14:03:00 +0200</lastBuildDate><atom:link href="https://blog.vtemian.com/tags/multiple-inheritance/index.xml" rel="self" type="application/rss+xml"/><item><title>Python Multiple Inheritance</title><link>https://blog.vtemian.com/post/multiple-inheritance/</link><pubDate>Fri, 01 May 2020 14:03:00 +0200</pubDate><guid>https://blog.vtemian.com/post/multiple-inheritance/</guid><description>Inheritance, a simple and evil mechanism for re-using code, can get tricky. Traditionally, you may have encountered inheritance when you wanted to extend or override a class&amp;rsquo;s behavior.
class Pet: def walk(self): print(&amp;quot;walk&amp;quot;) def eat(self): print(&amp;quot;talk&amp;quot;) def talk(self): print(&amp;quot;!@#$&amp;quot;) class Dog(Pet): def talk(self): print(&amp;quot;Ham!&amp;quot;) class Cat(Pet): def talk(self): print(&amp;quot;Miau!&amp;quot;) Fairly easy to understand and follow. Dog and Cat share most of Pet&amp;rsquo;s behavior, with some &amp;ldquo;small&amp;rdquo; particularities. Let&amp;rsquo;s say that we want to isolate particular behavior, for better testing purposes.</description></item></channel></rss>